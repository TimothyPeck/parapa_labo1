package ch.hearc.parapa_II.labo;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.FutureTask;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import ch.hearc.parapa_II.labo.Log.Type;

public class WaitingLogger {
	// Singleton lock
	private final static ReentrantLock lockSingleton = new ReentrantLock();
	private static WaitingLogger instance;

	private Map<Person, List<Log>> personLogs;
	private Map<Document, List<Log>> documentLogs;

	private Lock waitingLock = new ReentrantLock(true);

	/*
	 * -----------------------------------------------------------------------------
	 * ------------------
	 * DONE : Prevoir un stockage concurrent pour les logs et pour les listes
	 * d'attente des documents
	 * 
	 * Remarque : java.util.concurrent contient tout ce qu'il faut
	 * -----------------------------------------------------------------------------
	 * ------------------
	 */

	// Variables
	private ArrayList<Person> persons;
	private int nbPersonsDone = 0;

	// Singletons
	private Database db;
	private FutureTask<String> consoleFuture;

	/**
	 * Constructor
	 */
	private WaitingLogger() {
		db = Database.getInstance();
	}

	/**
	 * Singleton instance
	 * 
	 * @return the instance of the waiting logger
	 */
	public static WaitingLogger getInstance() {
		lockSingleton.lock();
		if (instance == null) {
			instance = new WaitingLogger();
		}
		lockSingleton.unlock();

		return instance;
	}

	/**
	 * Assign the future task to be able to cancel it when all threads are done
	 * 
	 * @param consoleFuture Future task running the main thread
	 * @param persons       List of persons generated by the main thread
	 */
	public void assignConsoleFuture(FutureTask<String> consoleFuture, ArrayList<Person> persons) {
		this.consoleFuture = consoleFuture;
		this.persons = persons;

		CopyOnWriteArrayList<Document> documents = db.getDocuments();
		personLogs = new TreeMap<>();
		documentLogs = new TreeMap<>();
		for (Person person : persons) {
			try {
				personLogs.put(person, new ArrayList<Log>());
			} catch (Exception e) {
				System.out.println(e.getMessage());
			}
		}
		for (Document document : documents) {
			try {
				documentLogs.put(document, new ArrayList<Log>());
			} catch (Exception e) {
				System.out.println(e.getMessage());
			}
		}
	}

	/**
	 * Add a thread to the waiting queue
	 * 
	 * @param p     Person waiting to access a document
	 * @param timer Time of the operation
	 */
	public void addWaiting(Person p, long timer) {
		/*
		 * -----------------------------------------------------------------------------
		 * ------
		 * DONE : Ajouter une personne (thread) dans la liste d'attente d'acces a son
		 * document
		 * 
		 * Remarque : ne pas oublier la concurrence
		 * -----------------------------------------------------------------------------
		 * ------
		 */
		Log log = new Log(Log.Type.WAITING, p, timer);

		waitingLock.lock();
		personLogs.get(p).add(log);
		documentLogs.get(p.getDocument()).add(log);
		waitingLock.unlock();

	}

	/**
	 * Remove a thread from the waiting queue and add it to the processing queue
	 * 
	 * @param p     Person accessing the document
	 * @param timer Time of the operation
	 */
	public void removeWaiting(Person p, long timer) {
		/*
		 * -----------------------------------------------------------------------------
		 * ----
		 * DONE : Enlever une personne (thread) de la liste d'attente d'acces a son
		 * document
		 * 
		 * Remarque : ne pas oublier la concurrence
		 * -----------------------------------------------------------------------------
		 * ----
		 */
		Log log = new Log(Log.Type.REMOVE, p, timer);
		waitingLock.lock();
		personLogs.get(p).add(log);
		documentLogs.get(p.getDocument()).add(log);
		waitingLock.unlock();
	}

	/**
	 * Remove a thread from the processing queue
	 * 
	 * @param p     Person finishing to access the document
	 * @param timer Time of the operation
	 */
	public void finished(Person p, long timer) {
		/*
		 * --------------------------------------------
		 * DONE : Indiquer la fin d'acces a un document
		 * 
		 * Remarque : ne pas oublier la concurrence
		 * --------------------------------------------
		 */
		Log log = new Log(Log.Type.FINISHED, p, timer);
		personLogs.get(p).add(log);
		documentLogs.get(p.getDocument()).add(log);
		nbPersonsDone++;
	}

	/**
	 * Called by the user on typing 'NEXT', display the next operation logged
	 */
	public boolean popNextLog() {
		Timer timer = Timer.getInstance();

		long frameLength = 100;
		long currentTime = timer.timePassed();

		printThreadInfo();
		printDocumentInfo();
		printThreadTimeline(currentTime, frameLength);

		return stopMain();
	}

	/**
	 * This function prints information about threads in a formatted way.
	 */
	private void printThreadInfo() {
		String output = "## Threads : ##\n\n";

		for (Map.Entry<Person, List<Log>> entry : personLogs.entrySet()) {
			Person p = entry.getKey();
			output += " ~ " + p.getName() + "(" + p.getRole() + ") reading " + p.getDocument().getName() + " at time "
					+ p.getStartingTime() + " for " + p.getDurationTime() + "ms\n";

		}

		System.out.println(output);
	}

	// The `printDocumentInfo()` method is responsible for printing information
	// about the documents
	// being accessed by the threads. It iterates over the `documentLogs` map, which
	// contains a list
	// of logs for each document, and extracts the list of persons waiting to access
	// the document and
	// the list of persons currently processing the document. It then formats this
	// information into a
	// string and prints it to the console.
	private void printDocumentInfo() {
		String output = "## Documents : ##\n\n";

		for (Map.Entry<Document, List<Log>> entry : documentLogs.entrySet()) {
			Document d = entry.getKey();
			List<Log> logs = entry.getValue();

			List<Person> personsWaiting = new ArrayList<>();
			List<Person> personsProcessing = new ArrayList<>();

			for (Log log : logs) {
				if (log.getType() == Log.Type.WAITING) {
					personsWaiting.add(log.getPerson());
				} else if (log.getType() == Log.Type.REMOVE) {
					personsWaiting.remove(log.getPerson());
					personsProcessing.add(log.getPerson());
				} else if (log.getType() == Log.Type.FINISHED) {
					personsProcessing.remove(log.getPerson());
				}
			}

			output += " ~ " + d.getName() + " is being accessed by : ";

			for (Person person : personsWaiting) {
				output += person.getName() + "(" + person.getRole() + ") ";
			}

			output += "\n";

			output += " ~ " + d.getName() + " is being processed by : ";

			for (Person person : personsProcessing) {
				output += person.getName() + "(" + person.getRole() + ") ";
			}

			output += "\n";

			System.out.println(output);
		}

		System.out.println(output);
	}

	/**
	 * The function prints a timeline of events for each person in the personLogs
	 * map.
	 * 
	 * @param currentTime The current time in milliseconds.
	 * @param frameLength The length of each frame in milliseconds.
	 */
	private void printThreadTimeline(long currentTime, long frameLength) {
		String output = "## Timeline : ##\n\n";

		output += "                     0";

		for (int i = 1; i * 1000 < currentTime; i++) {
			output += "         " + i;
		}

		output += "\n";

		for (Map.Entry<Person, List<Log>> entry : personLogs.entrySet()) {
			Type type = null;

			Person p = entry.getKey();
			String outLine = p.getName() + "(" + p.getRole() + ") : ";

			int counter = 0;
			String separator = " ";

			for (Log log : entry.getValue()) {
				type = log.getType();
				if (type == Type.WAITING) {
					separator = " ";
				} else if (type == Type.REMOVE) {
					if (log.getTime() <= counter) {
						char[] chars = outLine.toCharArray();
						chars[chars.length - 1] = 'T';
						outLine = new String(chars);
						continue;
					}
					separator = " ";
				} else {
					separator = "-";
				}
				counter += frameLength;
				while (log.getTime() > counter) {
					outLine += separator;
					counter += frameLength;
				}
				if (type == Type.WAITING)
					outLine += "W";
				else if (type == Type.REMOVE)
					outLine += "R";
				else if (type == Type.FINISHED)
					outLine += "F";
			}
			String lastChar = Character.toString(outLine.charAt(outLine.length() - 1));
			if (lastChar.equals("T") || lastChar.equals("R")) {
				while (currentTime > counter) {
					outLine += separator;
					counter += frameLength;
				}
			}
			output += outLine + "\n";
		}

		System.out.println(output);
	}

	/**
	 * The function returns true if the number of persons done is equal to the total
	 * number of persons.
	 * 
	 * @return The method `stopMain()` is returning a boolean value. It is checking
	 *         if the number of
	 *         persons who have completed their task (`nbPersonsDone`) is equal to
	 *         the total number of persons
	 *         (`persons.size()`). If they are equal, it returns `true`, indicating
	 *         that the main program should
	 *         stop. Otherwise, it returns `false`, indicating that the program
	 *         should continue running.
	 */
	private boolean stopMain() {
		return nbPersonsDone >= persons.size();
	}

	/**
	 * The function returns the result of calling the stopMain() method as a boolean
	 * value.
	 * 
	 * @return A boolean value is being returned, which is the result of calling the
	 *         method `stopMain()`.
	 */
	public boolean isDone() {
		return stopMain();
	}
}
